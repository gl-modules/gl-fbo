"use strict";

var webglew = require("webglew")
  , createTexture = require("gl-texture2d")

var colorAttachmentArrays = null

function lazyInitColorAttachments(gl, ext) {
  var maxColorAttachments = gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);
  colorAttachmentArrays = new Array(maxColorAttachments + 1)
  for(var i=0; i<=maxColorAttachments; ++i) {
    var x = new Array(maxColorAttachments)
    for(var j=0; j<i; ++j) {
      x[j] = gl.COLOR_ATTACHMENT0 + j
    }
    for(var j=i; j<maxColorAttachments; ++j) {
      x[j] = gl.NONE
    }
    colorAttachmentArrays[i] = x
  }
}

function initTexture(gl, width, height, type, format, attachment) {
  if(!type) {
    return null
  }
  var result = createTexture(gl, width, height, format, type)
  result.magFilter = gl.NEAREST
  result.minFilter = gl.NEAREST
  result.mipSamples = 1
  gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, result.handle, 0)
  gl.bindTexture(gl.TEXTURE_2D, null)
  return result
}

function initRenderBuffer(gl, width, height, component, attachment) {
  var result = gl.createRenderbuffer()
  gl.bindRenderbuffer(gl.RENDERBUFFER, result)
  gl.renderbufferStorage(gl.RENDERBUFFER, component, width, height)
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, result)
  return result
}

function Framebuffer(gl, width, height, colorType, numColor, useDepth, useStencil, ext) {
  var extensions = webglew(gl)

  //Create storage
  this.gl = gl
  this._width = width|0
  this._height = height|0
  this._destroyed = false
  this.handle = gl.createFramebuffer()
  this._ext = ext
  this._dirty = true
  this._extensions = extensions
  this._numColor = numColor
  this._colorType = colorType
  this._useDepth = useDepth
  this._useStencil = useStencil

  gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle)
  this.allocateColorBuffers()
  this.allocateOtherBuffers()

  if(numColor === 0) {
    if(ext) {
      ext.drawBuffersWEBGL(colorAttachmentArrays[0])
    }
  } else if(numColor > 1) {
    ext.drawBuffersWEBGL(colorAttachmentArrays[numColor])
  }

  this.checkState()
  this.gl.bindFramebuffer(gl.FRAMEBUFFER, null)
}

Framebuffer.prototype.allocateColorBuffers = function() {
  var colorType = this._colorType
  var numColor = this._numColor
  var height = this.height
  var width = this.width
  var gl = this.gl

  this.color = new Array(numColor)
  this._color_rb = null
  for(var i=0; i<numColor; ++i) {
    this.color[i] = initTexture(gl, width, height, colorType, gl.RGBA, gl.COLOR_ATTACHMENT0 + i)
  }
  if(numColor === 0) {
    this._color_rb = initRenderBuffer(gl, width, height, gl.RGBA4, gl.COLOR_ATTACHMENT0)
  }
}

Framebuffer.prototype.allocateOtherBuffers = function() {
  var useStencil = this._useStencil
  var extensions = this._extensions
  var useDepth = this._useDepth
  var height = this.height
  var width = this.width
  var gl = this.gl

  //Allocate depth/stencil buffers
  this.depth = null
  this._depth_rb = null

  if(extensions.WEBGL_depth_texture) {
    if(useStencil) {
      this.depth = initTexture(gl, width, height,
                          extensions.WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL,
                          gl.DEPTH_STENCIL,
                          gl.DEPTH_STENCIL_ATTACHMENT)
    } else if(useDepth) {
      this.depth = initTexture(gl, width, height,
                          gl.UNSIGNED_SHORT,
                          gl.DEPTH_COMPONENT,
                          gl.DEPTH_ATTACHMENT)
    }
  } else {
    if(useDepth && useStencil) {
      this._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_STENCIL, gl.DEPTH_STENCIL_ATTACHMENT)
    } else if(useDepth) {
      this._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_COMPONENT16, gl.DEPTH_ATTACHMENT)
    } else if(useStencil) {
      this._depth_rb = initRenderBuffer(gl, width, height, gl.STENCIL_INDEX, gl.STENCIL_ATTACHMENT)
    }
  }
}

Framebuffer.prototype._resize = function(width, height) {
  var gl = this.gl

  gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle)
  this.disposeBuffers()
  this.allocateColorBuffers()
  this.allocateOtherBuffers()
  this._dirty = false

  this.checkState()
  gl.bindFramebuffer(gl.FRAMEBUFFER, null)
}

Object.defineProperty(Framebuffer.prototype, 'width', {
  get: function() { return this._width },
  set: function(value) {
    value = value|0
    if (value === this._width) return
    this._width = value
    this._dirty = true
  }
})

Object.defineProperty(Framebuffer.prototype, 'height', {
  get: function() { return this._height },
  set: function(value) {
    value = value|0
    if (value === this._height) return
    this._height = value
    this._dirty = true
  }
})

Framebuffer.prototype.checkState = function() {
  var gl = this.gl
  var valid = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  switch(valid){
      case gl.FRAMEBUFFER_UNSUPPORTED:
          throw "gl-fbo: Framebuffer unsupported";
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw "gl-fbo: Framebuffer incomplete attachment";
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw "gl-fbo: Framebuffer incomplete dimensions";
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw "gl-fbo: Framebuffer incomplete missing attachment";
  }
}

Object.defineProperty(Framebuffer.prototype, "valid", {
  get: function() {
    return !this._destroyed
  }
});

Object.defineProperty(Framebuffer.prototype, "shape", {
  get: function() {
    return [this.height, this.width]
  }
})

Framebuffer.prototype.bind = function() {
  if(!this.valid) {
    return
  }
  if (this._dirty) {
    this._resize(this.width, this.height)
  }
  var gl = this.gl
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle)
  gl.viewport(0, 0, this.width, this.height)
}

Framebuffer.prototype.dispose = function() {
  if(!this.valid) {
    return
  }
  this._destroyed = true
  var gl = this.gl
  gl.deleteFramebuffer(this.handle)
  this.handle = null
  this.disposeBuffers()
}

Framebuffer.prototype.disposeBuffers = function() {
  var gl = this.gl

  if(this.depth) {
    this.depth.dispose()
    this.depth = null
  }
  if(this._depth_rb) {
    gl.deleteRenderbuffer(this._depth_rb)
    this._depth_rb = null
  }
  for(var i=0; i<this.color.length; ++i) {
    this.color[i].dispose()
    this.color[i] = null
  }
  if(this._color_rb) {
    gl.deleteRenderbuffer(this._color_rb)
    this._color_rb = null
  }
}

function createFBO(gl, width, height, options) {
  var extensions = webglew(gl)
    , colorType
    , numColors
    , useDepth
    , useStencil
  //Lazily initialize color attachment arrays
  if(!colorAttachmentArrays && extensions.WEBGL_draw_buffers) {
    lazyInitColorAttachments(gl, extensions.WEBGL_draw_buffers)
  }
  options = options || {}
  numColors = 1
  if("color" in options) {
    numColors = Math.max(options.color|0, 0)
    if(numColors > 1) {
      //Check if multiple render targets supported
      var mrtext = extensions.WEBGL_draw_buffers
      if(!mrtext) {
        numColors = 1
      } else {
        numColors = Math.min(numColors, gl.getParameter(mrtext.MAX_COLOR_ATTACHMENTS_WEBGL))|0
      }
    }
  }
  colorType = gl.UNSIGNED_BYTE;
  if(options.float && numColors > 0 && extensions.OES_texture_float) {
    colorType = gl.FLOAT
  }
  useDepth = true
  if("depth" in options) {
    useDepth = !!options.depth
  }
  useStencil = false
  if("stencil" in options) {
    useStencil = !!options.stencil
  }
  return new Framebuffer(
    gl, 
    width, 
    height, 
    colorType, 
    numColors, 
    useDepth, 
    useStencil, 
    extensions.WEBGL_draw_buffers)
}
module.exports = createFBO
